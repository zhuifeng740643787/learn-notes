# 外观模式(Facade)

## 概念
- 为子系统中的一组接口提供一个统一接口。定义一个更高层的接口，使子系统更加容易使用

## 角色
- 门面角色：客户端可以调用这个角色的方法。此角色知道子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统中去。
- 子系统角色：可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。每个子系统都可以被客户端直接调用，或者被门面角色调用。

## 优点
- 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。
- 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。
- 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。
- 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。

## 缺点
- 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。
- 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”

## 总结
- Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。Facade更注重简化接口，Adapter模式注重转换接口，Bridge模式注重分离接口(抽象)与其实现，Decorator模式注重稳定接口的前提下为对象扩展功能。

## 示例
以到商店买东西为例，一般情况下，我们要买东西都是直接到商店去买，而不是到生产产品的工厂去买，这里的商店就可以看成是一个门面，然后工厂就是一个一个的子系统，当你需要什么货品时，直接去商店买就是了，不用管工厂的事，商店来根据你要的产品，选择不同的工厂来进货。

    <?php
    /*外套类*/
    class Coat {
      function __toString() {
        return "一件外套";
      }
    }
    /*外套工厂类*/
    class CoatFactory {
      function saleCoat(){
        return new Coat();
      }
    }
    /*苹果类*/
    class Apple {
      function __toString() {
        return "一箱苹果";
      }
    }
    /*苹果工厂类*/ 
    class AppleFactory {
      function saleApple(){
        return new Apple();
      }
    }

    /*商店类*/
    class Store {
      function saleCoat() {
        $coatFactory = new CoatFactory();
        return $coatFactory->saleCoat(); 
      }
      function saleApple() {
        $appleFactory = new AppleFactory();
        return $appleFactory->saleApple(); 
      }
    }

    /*顾客调用*/
    $store = new Store();
    $store->saleCoat();
    $store->saleApple();


