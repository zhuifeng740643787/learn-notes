# PHP7性能提升
- 新特性
	+ 新增强制类型定义，开启strict_type
	+ Int64支持，统一不同平台下的整型长度，字符串和文件上传都支持大于2GB。
	+ 统一变量语法（Uniform variable syntax）。
	+ foreach表现行为一致（Consistently foreach behaviors）
	+ 新的操作符 <=>, ??
	+ Unicode字符格式支持（\u{xxxxx}）
	+ 匿名类支持（Anonymous Class）
	
- 更多的Error变为可捕获
	+ 实现了一个全局的throwable接口，原来的Exception和部分Error都实现了这个接口
	+ 更多错误可以返回给开发者进行处理，而不是直接报错，停止程序执行

- AST(语法抽象树)
	+ 在PHP编译过程作为中间件的角色替换原来直接从解释器吐出opcode的方式，让解释器和编译器解耦，可以减少一些hack代码，让程序更好理解和维护
	+ PHP5: PHP代码 -> Parser(语法词法解析) -> Opcode中间字节码 -> 执行
	+ PHP7: PHP代码 -> Parser(语法词法解析) -> AST -> Opcode中间字节码 -> 执行

- Native TLS（原生线程本地存储）
	+ 多线程模式下，需要保护线程的私有数据不被其他线程污染
	+ PHP5: 维护一个全局大数组，每个线程分配一份独立的存储空间，线程通过独有的key方位这个全局数组
	+ PHP7: 采用一个全局的线程特定变量来保存这个key

- Zval的改变
	+ PHP5的Zval，内存占据24个字节
	+ PHP7的Zval，内存占据16个字节, 多个union，部分简单类型不再使用引用（长度<=64bit）

- 内部类型zend_string
	+ zend_string是实际存储字符串的结构体，实际的内容会存储在val（char，字符型）中，而val是一个char数组，长度为1（方便成员变量占位）
	+ 结构体最后一个成员变量采用char数组，而不是使用char*,申请的内存在同一块区域，可提高缓存命中率

- 数组变化
	+ PHP5: 
		- 一个支持双向链表的hashtable
		- 通过key值访问时，指针跳来跳去，有时需3次跳跃才能找到，原因在于数组的各元素分散在各不同的内存区域，CPU读取的时候不在同一级缓存，引起缓存命中下降,增加耗时
	+ PHP7:
		- 整块的数组元素和hash映射全部连接在一起，被分配在同一块内存内
		- 数组元素的zval会把整型元素存储在内部，也不再有指针外链，全部数据都存储在当前内存区域内
			- 变化
				1. 数组的value默认为zval。
				2. HashTable的大小从72下降到56字节，减少22%。
				3. Buckets的大小从72下降到32字节，减少50%。
				4. 数组元素的Buckets的内存空间是一同分配的。
				5. 数组元素的key（Bucket.key）指向zend_string。
				6. 数组元素的value被嵌入到Bucket中。
				7. 降低CPU Cache Miss。

- 函数调用机制
	+ PHP7改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率。
	+ 在vm栈中的指令send_val和recv参数的指令是相同，PHP7通过减少这两条重复，来达到对函数调用机制的底层优化。

- 通过宏定义和内联函数，让编译器提前完成部分工作
	+ C语言的宏定义会被在预处理阶段（编译阶段）执行，提前将部分工作完成，无需在程序运行时分配内存，能够实现类似函数的功能，却没有函数调用的压栈、弹栈开销，效率会比较高。
	+ 内联函数也类似，在预处理阶段，将程序中的函数替换为函数体，真实运行的程序执行到这里，就不会产生函数调用的开销。
	+ 将不少需要在运行阶段要执行的工作，放到了编译阶段。例如参数类型的判断（Parameters Parsing），因为这里涉及的都是固定的字符常量，因此，可以放到到编译阶段来完成，进而提升后续的执行效率。











